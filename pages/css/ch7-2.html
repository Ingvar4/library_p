<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <link rel="shortcut icon" href="../../images/image.jpg" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS</title>
    <link rel="stylesheet" href="../../styles/style.css">
    <link rel="stylesheet" href="../../styles/prism.css">
    <script src="../../scripts/prism.js" defer></script>
    <script src="../../scripts/script.js" defer></script>
    <style>
      .button {
        background-color: blue;
        transition: background-color 0.3s ease;
        padding: 20px;
      }
      
      .button:hover {
        background-color: red;
      }

      .box {
        width: 100px;
        height: 100px;
        background-color: green;
        transition: width 0.5s ease-in, height 0.5s ease-out, transform 0.5s;
      }
      
      .box:hover {
        width: 200px;
        height: 200px;
        transform: rotate(45deg);
      }
      
      .menu {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.5s ease-out;
      }

      .menu.open {
        max-height: 500px; /* Достаточное значение для содержимого */
      }
    </style>
  </head>

  <body>
    <!--шапка с кнопками переходами-->
    <header class="main-header-top">
      <div class="header-logo">
        <img src="../../images/image2.png">
      </div>
      
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../../pages/html.html">HTML</a></li>
        <li><a href="../../pages/css.html">CSS</a></li>
        <li><a href="../../pages/js.html">JS</a></li>
      </ul>
    </header>

    <!--основной блок с информацией-->
    <main>
      <article>
        <h1>Переходы: transition, как задать временные интервалы и задержки.</h1><hr>
        <p>Переходы в CSS используются для анимирования изменений свойств элементов, таких как цвет, размер, положение и непрозрачность, когда они происходят из-за действия пользователя (например, при наведении курсора) или других событий.</p>
        <h4>Синтаксис</h4>
        <p>Основное свойство для задания переходов — это <code>transition</code>. Оно может быть применено ко многим CSS-свойствам одновременно.</p>
<pre>
  <code class="lang-css">
    /*CSS*/

    selector {
      transition: property duration timing-function delay;
    }
  </code>
</pre>
        <ul>
          <li><strong>property</strong>: Свойство, для которого задается переход (например, <code>width</code>, <code>background-color</code>, <code>transform</code>). Можно указать <code>all</code>, чтобы применить переход ко всем изменяющимся свойствам.</li>
          <li><strong>duration</strong>: Продолжительность перехода, указывается в секундах или миллисекундах (например, <code>2s</code> или <code>500ms</code>).</li>
          <li><strong>timing-function</strong>: Функция расчета времени (кривая ускорения), определяет, как скорость перехода изменяется в течение его продолжительности. Значения: <code>linear</code>, <code>ease</code>, <code>ease-in</code>, <code>ease-out</code>, <code>ease-in-out</code>, или функция <code>cubic-bezier</code>.</li>
          <li><strong>delay</strong>: Задержка перед началом перехода, указывается в секундах или миллисекундах (например, <code>1s</code> или <code>200ms</code>).</li>
        </ul>
        <hr>

        <h3>Примеры использования</h3>
        <h4>Переход цвета при наведении</h4>
<pre>
  <code class="lang-css">
    /*CSS*/

    .button {
      background-color: blue;
      transition: background-color 0.3s ease;
    }
    
    .button:hover {
      background-color: red;
    }
  </code>
</pre>

        <div class="result">
          <p class="resultP"><strong>Результат:</strong></p>
          
          <button class="button">Цветовые переходы</button>
        </div>

        <ul>
          <li>В этом примере цвет фона <code>.button</code> плавно изменяется с синего на красный за 0.3 секунды с использованием кривой ускорения <code>ease</code>.</li>
        </ul>
        <h4>Переход размеров и позиции</h4>
<pre>
  <code class="lang-css">
    /*CSS*/

    .box {
      width: 100px;
      height: 100px;
      background-color: green;
      transition: width 0.5s ease-in, height 0.5s ease-out, transform 0.5s;
    }
    
    .box:hover {
      width: 200px;
      height: 200px;
      transform: rotate(45deg);
    }
  </code>
</pre>

        <div class="result">
          <p class="resultP"><strong>Результат:</strong></p>
          
          <div class="box"></div>
        </div>

        <ul>
          <li>Здесь изменяются ширина, высота и вращение элемента <code>.box</code> при наведении. Ширина увеличивается с эффектом <code>ease-in</code>, высота с эффектом <code>ease-out</code>, а поворот использует линейную скорость.</li>
        </ul>
        <hr>

        <h3>Свойства перехода по отдельности</h3>
        <p>Кроме сокращенной записи <code>transition</code>, вы можете использовать отдельные свойства для более точного управления:</p>
        <ol>
          <li><code>transition-property</code>: Указывает, для каких CSS-свойств должен применяться переход.</li>
<pre>
  <code class="lang-css">
    /*CSS*/

    transition-property: opacity, transform;
  </code>
</pre>
          <li><code>transition-duration</code>: Определяет длительность перехода.</li>
<pre>
  <code class="lang-css">
    /*CSS*/

    transition-duration: 1s, 2s;
  </code>
</pre>
          <li><code>transition-timing-function</code>: Задает функцию временной кривой перехода.</li>
<pre>
  <code class="lang-css">
    /*CSS*/

    transition-timing-function: ease-in-out, linear;
  </code>
</pre>
          <li><code>transition-delay</code>: Устанавливает задержку перед запуском перехода.</li>
<pre>
  <code class="lang-css">
    /*CSS*/

    transition-delay: 0.5s, 1s;
  </code>
</pre>
        </ol>
        <hr>

        <h3>Детали функций времени (timing-function)</h3>
        <h4>Стандартные временные функции</h4>
        <ol>
          <li><code>linear</code>: Переход происходит с постоянной скоростью от начала до конца.</li>
          <li><code>ease</code>: Плавное ускорение в начале и замедление в конце (по умолчанию).</li>
          <li><code>ease-in</code>: Медленный старт с ускорением.</li>
          <li><code>ease-out</code>: Замедление к концу.</li>
          <li><code>ease-in-out</code>: Медленный старт, ускорение в середине, замедление в конце.</li>
        </ol>
        <h4>Функция cubic-bezier</h4>
        <p>Если вам нужно более детальное управление кривой ускорения, используйте функцию <code>cubic-bezier</code>.</p>
<pre>
  <code class="lang-css">
    /*CSS*/

    transition-timing-function: cubic-bezier(0.68, -0.55, 0.27, 1.55);
  </code>
</pre>
        <ul>
          <li>Аргументы задают кривую Бе́зье для создания пользовательских временных функций.</li>
          <li>Существуют онлайн-инструменты для визуального создания кривых Бе́зье.</li>
        </ul>
        <hr>

        <h3>Множественные переходы</h3>
        <p>Вы можете применить переходы к нескольким свойствам одновременно, перечисляя их через запятую.</p>
<pre>
  <code class="lang-css">
    /*CSS*/

    .element {
      transition: opacity 1s, transform 0.5s;
    }
  </code>
</pre>
        <ul>
          <li>Здесь <code>opacity</code> изменяется за 1 секунду, а <code>transform</code> за 0.5 секунды.</li>
        </ul>

        <h3>Советы по использованию переходов</h3>
        <ol>
          <li><strong>Оптимизируйте производительность</strong>: Избегайте анимаций тяжелых свойств (таких как <code>width</code> и <code>height</code>). Лучше используйте <code>transform</code> и <code>opacity</code>, так как они лучше оптимизируются браузером.</li>
          <li><strong>Сложные анимации</strong>: Для более сложных анимаций рассмотрите использование CSS-анимаций с <code>@keyframes</code>.</li>
          <li><strong>Обратная связь пользователя</strong>: Используйте переходы для создания более отзывчивого интерфейса, но не злоупотребляйте ими.</li>
        </ol>
        <hr>

        <h3>Сложные примеры переходов</h3>
        <h4>1. Плавное раскрытие меню</h4>
        <p>Когда вам нужно создать эффект раскрытия меню, использование переходов для высоты может вызвать проблемы с производительностью и сложностью. Вместо этого лучше использовать переход <code>max-height</code> вместе с <code>overflow: hidden</code>.</p>
<pre>
  <code class="lang-css">
    /*CSS*/

    .menu {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.5s ease-out;
    }
    
    .menu.open {
      max-height: 500px; /* Достаточное значение для содержимого */
    }
  </code>
</pre>
        <ul>
          <li>Принцип работы: Меню плавно раскрывается с помощью изменения <code>max-height</code>, а не <code>height</code>, чтобы избежать проблем с непредсказуемым поведением.</li>
        </ul>
        <hr>

        <h4>2. Переходы на основе состояния с использованием :hover и :focus</h4>
        <p>Иногда нужно задать разные переходы для состояний, таких как наведение курсора или фокусировка.</p>
<pre>
  <code class="lang-css">
    /*CSS*/

    .input-field {
      border: 1px solid #ccc;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    
    .input-field:focus {
      border-color: #007BFF;
      box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
    }
  </code>
</pre>
        <p>Применение: Плавный переход цвета границы и эффекта тени при фокусе.</p>
        <hr>

        <h4>3. Переходы с transform для оптимизации производительности</h4>
        <p>Анимации, использующие свойства <code>transform</code> и <code>opacity</code>, более производительны по сравнению с изменением других свойств, поскольку браузеры могут лучше управлять ими с использованием аппаратного ускорения.</p>
<pre>
  <code class="lang-css">
    /*CSS*/

    .card {
      transform: translateY(0);
      transition: transform 0.3s ease, opacity 0.3s ease;
      opacity: 1;
    }
    
    .card.hidden {
      transform: translateY(20px);
      opacity: 0;
    }
  </code>
</pre>
        <p>Применение: Карточка плавно исчезает и смещается вниз. Это полезно для создания интерактивных интерфейсов с хорошей производительностью.</p>
        <hr>

        <h3>Лучшие практики и советы по переходам</h3>
        <ol>
          <li><strong>Управление временем и функцией времени</strong>
            <ul>
              <li>Старайтесь делать переходы достаточно быстрыми, чтобы не раздражать пользователей, но не слишком короткими, чтобы они были заметными. В большинстве случаев 0.2–0.5 секунды является хорошим диапазоном.</li>
              <li>Используйте различные временные функции (<code>ease-in</code>, <code>ease-out</code>, <code>linear</code>) в зависимости от эффекта. Например, для кнопок обычно подходит <code>ease-out</code>, чтобы эффект был более плавным к концу.</li>
            </ul>
          </li>
          <li><strong>Переработка макета и перерисовка</strong>
            <ul>
              <li>Избегайте анимации свойств, которые вызывают переработку макета или перерисовку, таких как <code>width</code>, <code>height</code>, <code>margin</code>, <code>padding</code>. Это может привести к задержкам и снижению производительности.</li>
              <li>Вместо этого используйте <code>transform</code> и <code>opacity</code>, чтобы сократить нагрузку на процессор.</li>
            </ul>
          </li>
          <li><strong>Задержки переходов и каскадные эффекты</strong>
            <p>Задержки могут использоваться для создания каскадных эффектов, когда один элемент анимируется за другим.</p>
<pre>
  <code class="lang-css">
    /*CSS*/

    .list-item {
      opacity: 0;
      transform: translateY(10px);
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    .list-item:nth-child(1) {
      transition-delay: 0s;
    }
    
    .list-item:nth-child(2) {
      transition-delay: 0.1s;
    }
    
    .list-item:nth-child(3) {
      transition-delay: 0.2s;
    }
  </code>
</pre>
          </li>
          <ul>
            <li>Результат: Элементы списка появляются с задержкой один за другим, создавая эффект каскада.</li>
          </ul>
        </ol>
        <hr>

        <h4>4. Комбинирование переходов с JavaScript</h4>
        <p>Для более сложных сценариев, таких как анимации, зависящие от пользовательских событий, можно использовать JavaScript в сочетании с переходами.</p>
<pre>
  <code class="lang-js">
    //JS

    const button = document.querySelector(".toggle-button");
    const menu = document.querySelector(".menu");

    button.addEventListener("click", () => {
      menu.classList.toggle("open");
    });
  </code>
</pre>

        <ul>
          <li>Пояснение: В этом примере JavaScript добавляет или удаляет класс open у меню, что активирует CSS-переход.</li>
        </ul>

        <h4>5. Анимации обратного действия</h4>
        <p>Иногда требуется, чтобы элемент имел разные скорости переходов для появления и исчезновения. Это можно сделать, используя состояния.</p>
<pre>
  <code class="lang-css">
    /*CSS*/

    .modal {
      opacity: 0;
      transform: scale(0.9);
      transition: opacity 0.3s ease-out, transform 0.3s ease-out;
    }
    
    .modal.open {
      opacity: 1;
      transform: scale(1);
      transition: opacity 0.5s ease-in, transform 0.5s ease-in;
    }
  </code>
</pre>
        <ul>
          <li>Применение: При открытии модального окна переход происходит медленнее, чем при его закрытии.</li>
        </ul>
        <hr>
      </article>
    </main>

    <!--блок в нижней части страницы-->
    <footer> 
      <p>©Copyright 2024 by nobody. All rights reversed.</p>
    </footer>

  </body>
</html>