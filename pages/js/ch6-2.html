<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8">
    <link rel="shortcut icon" href="../../images/image.jpg" type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS</title>
    <link rel="stylesheet" href="../../styles/style.css">
    <link rel="stylesheet" href="../../styles/prism.css">
    <script src="../../scripts/prism.js" defer></script>
    <script src="../../scripts/script.js" defer></script>
  </head>

  <body>
    <!--шапка с кнопками переходами-->
    <header class="main-header-top">
      <div class="header-logo">
        <img src="../../images/image2.png">
      </div>
      
      <ul>
        <li><a href="../../index.html">Home</a></li>
        <li><a href="../../pages/html.html">HTML</a></li>
        <li><a href="../../pages/css.html">CSS</a></li>
        <li><a href="../../pages/js.html">JS</a></li>
      </ul>
    </header>

    <!--основной блок с информацией-->
    <main>
      <article>
        <h1>Решение задач на алгоритмы и логику</h1><hr>
        <h3>1. Что такое алгоритмы и задачи на логику?</h3>
        <ul>
          <li><strong>Алгоритм</strong> — это последовательность шагов, которая позволяет решить определённую задачу.</li>
          <li><strong>Задачи на логику</strong> проверяют вашу способность думать аналитически и находить решения нетривиальных задач.</li>
        </ul>
        <p>Примеры задач:</p>
        <ol>
          <li>Найти факториал числа.</li>
          <li>Определить, является ли строка палиндромом.</li>
          <li>Отсортировать массив.</li>
        </ol>
        <h3>2. Основные типы задач</h3>
        <h4>2.1. Задачи на массивы</h4>
        <ul>
          <li><strong>Поиск максимального/минимального элемента.</strong></li>
          <li><strong>Сортировка массива.</strong></li>
          <li><strong>Работа с подмассивами</strong> (например, найти подмассив с максимальной суммой).</li>
        </ul>
        <p>Пример: Найти сумму всех элементов массива:</p>
<pre>
  <code class="lang-js">
    const array = [1, 2, 3, 4];
    const sum = array.reduce((acc, curr) => acc + curr, 0);
    console.log(sum); // 10
  </code>
</pre>
        <h4>2.2. Задачи на строки</h4>
        <ul>
          <li><strong>Определение палиндрома.</strong></li>
          <li><strong>Подсчёт уникальных символов.</strong></li>
          <li><strong>Реверс строки.</strong></li>
        </ul>
        <p>Пример: Реверс строки:</p>
<pre>
  <code class="lang-js">
    const reverseString = str => str.split('').reverse().join('');
    console.log(reverseString('hello')); // 'olleh'
  </code>
</pre>
        <h4>2.3. Задачи на числа</h4>
        <ul>
          <li><strong>Поиск простых чисел.</strong></li>
          <li><strong>Числа Фибоначчи.</strong></li>
          <li><strong>Работа с системами счисления.</strong></li>
        </ul>
        <p>Пример: Определить, является ли число простым:</p>
<pre>
  <code class="lang-js">
    const isPrime = num => {
      if (num <= 1) return false;
      for (let i = 2; i < Math.sqrt(num) + 1; i++) {
        if (num % i === 0) return false;
      }
      return true;
    };
    console.log(isPrime(11)); // true
  </code>
</pre>
        <h3>3. Подходы к решению задач</h3>
        <h4>3.1. Понять задачу</h4>
        <ol>
          <li>Прочитайте условия внимательно.</li>
          <li>Разберите примеры, если они есть.</li>
          <li>Уточните ограничения (размеры входных данных, диапазоны чисел).</li>
        </ol>
        <h4>3.2. Разбить задачу на подзадачи</h4>
        <p>Например, задача "Найти все уникальные символы строки" может быть разбита так:</p>
        <ol>
          <li>Итерировать по строке.</li>
          <li>Проверить, встречался ли символ ранее.</li>
          <li>Сохранить уникальные символы.</li>
        </ol>
        <h4>3.3. Выбрать структуру данных</h4>
        <ul>
          <li>Массивы: для работы с последовательностями данных.</li>
          <li>Объекты или Map: для подсчёта частоты элементов.</li>
          <li>Множества (Set): для фильтрации уникальных значений.</li>
        </ul>
        <h3>4. Алгоритмические техники</h3>
        <h3>4.1. Жадные алгоритмы</h3>
        <p>Ищут локально оптимальное решение на каждом шаге, чтобы прийти к глобально оптимальному. Пример: Задача о сдаче монет.</p>
        <h4>4.2. Разделяй и властвуй</h4>
        <p>Разделяйте задачу на меньшие части, решайте их, а затем объединяйте результаты. Пример: Быстрая сортировка.</p>
        <h4>4.3. Динамическое программирование</h4>
        <p>Используется для задач, где большие проблемы можно разбить на перекрывающиеся подзадачи. Пример: Задача о рюкзаке.</p>
        <p>Пример динамического программирования:</p>
<pre>
  <code class="lang-js">
    const fibonacci = n => {
      const dp = [0, 1];
      for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
      }
      return dp[n];
    };
    console.log(fibonacci(10)); // 55
  </code>
</pre>
        <h4>4.4. Поиск с возвратом (Backtracking)</h4>
        <p>Используется для поиска всех возможных решений задачи. Например, задачи о восьми ферзях.</p>
        <h3>5. Важные алгоритмы</h3>
        <h4>5.1. Сортировки</h4>
        <ul>
          <li><strong>Пузырьковая.</strong></li>
          <li><strong>Быстрая (QuickSort).</strong></li>
          <li><strong>Слиянием (MergeSort).</strong></li>
        </ul>
        <p>Пример быстрой сортировки:</p>
<pre>
  <code class="lang-js">
    const quickSort = arr => {
      if (arr.length <= 1) return arr;
      const pivot = arr[arr.length - 1];
      const left = arr.filter(el => el < pivot);
      const right = arr.filter(el => el > pivot);
      return [...quickSort(left), pivot, ...quickSort(right)];
    };
    console.log(quickSort([3, 1, 4, 1, 5])); // [1, 1, 3, 4, 5]
  </code>
</pre>
        <h4>5.2. Поиск</h4>
        <ul>
          <li><strong>Линейный поиск.</strong></li>
          <li><strong>Бинарный поиск</strong> (только для отсортированных массивов).</li>
        </ul>
        <p>Пример бинарного поиска:</p>
<pre>
  <code class="lang-js">
    const binarySearch = (arr, target) => {
      let left = 0, right = arr.length - 1;
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (arr[mid] === target) return mid;
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
      }
      return -1;
    };
  console.log(binarySearch([1, 2, 3, 4, 5], 3)); // 2
  </code>
</pre>
        <h3>6. Советы по решению задач</h3>
        <ol>
          <li><strong>Практикуйтесь</strong>: используйте платформы, такие как LeetCode, Codewars, или HackerRank.</li>
          <li><strong>Читай чужой код</strong>: анализируйте решения других.</li>
          <li><strong>Развивайте навыки дебага</strong>: используйте console.log, дебаггеры в IDE или браузере.</li>
          <li><strong>Оптимизируйте</strong>: после написания решения подумайте, можно ли улучшить его.</li>
        </ol>
        <h3>7. Готовые задачи для практики</h3>
        <h4>Пример 1: Сумма чисел в диапазоне</h4>
<pre>
  <code class="lang-js">
    const sumRange = (start, end) => {
      let sum = 0;
      for (let i = start; i <= end; i++) {
        sum += i;
      }
      return sum;
    };
    console.log(sumRange(1, 5)); // 15
  </code>
</pre>
        <h4>Пример 2: Перемешать массив</h4>
<pre>
  <code class="lang-js">
    const shuffle = arr => arr.sort(() => Math.random() - 0.5);
    console.log(shuffle([1, 2, 3, 4, 5]));
  </code>
</pre>
        <h4>Пример 3: Найти второй максимальный элемент</h4>
<pre>
  <code class="lang-js">
    const secondMax = arr => {
      const max = Math.max(...arr);
      return Math.max(...arr.filter(el => el !== max));
    };
    console.log(secondMax([1, 2, 3, 4, 5])); // 4
  </code>
</pre>
        <h1>Дополнительно</h1>
        <h3>1. Задачи на строки</h3>
        <h4>1.1. Подсчёт количества вхождений символа</h4>
        <p>Найти, сколько раз символ встречается в строке.</p>
<pre>
  <code class="lang-js">
    const countOccurrences = (str, char) => {
      return str.split(char).length - 1;
    };
    console.log(countOccurrences("hello world", "o")); // 2
  </code>
</pre>
        <h4>1.2. Удаление гласных</h4>
        <p>Удалить все гласные из строки.</p>
<pre>
  <code class="lang-js">
    const removeVowels = str => {
      return str.replace(/[aeiou]/gi, '');
    };
    console.log(removeVowels("hello world")); // "hll wrld"
  </code>
</pre>
        <h4>1.3. Проверка анаграммы</h4>
        <p>Проверить, являются ли две строки анаграммами.</p>
<pre>
  <code class="lang-js">
    const isAnagram = (str1, str2) => {
      const normalize = str => str.toLowerCase().split('').sort().join('');
      return normalize(str1) === normalize(str2);
    };
    console.log(isAnagram("listen", "silent")); // true
  </code>
</pre>
        <h4>1.4. Реверс слов в предложении</h4>
        <p>Перевернуть слова, сохранив порядок слов.</p>
<pre>
  <code class="lang-js">
    const reverseWords = sentence => {
      return sentence.split(' ').map(word => word.split('').reverse().join('')).join(' ');
    };
    console.log(reverseWords("hello world")); // "olleh dlrow"
  </code>
</pre>
        <h3>2. Задачи на массивы</h3>
        <h4>2.1. Фильтрация уникальных значений</h4>
        <p>Вывести только уникальные значения массива.</p>
<pre>
  <code class="lang-js">
    const uniqueValues = arr => {
      return [...new Set(arr)];
    };
    console.log(uniqueValues([1, 2, 2, 3, 4, 4])); // [1, 2, 3, 4]
  </code class="lang-js">
</pre>
        <h4>2.2. Слияние и сортировка двух массивов</h4>
        <p>Объединить два массива и отсортировать их.</p>
<pre>
  <code class="lang-js">
    const mergeAndSort = (arr1, arr2) => {
      return [...arr1, ...arr2].sort((a, b) => a - b);
    };
    console.log(mergeAndSort([3, 1, 4], [5, 2])); // [1, 2, 3, 4, 5]
  </code>
</pre>
        <h4>2.3. Проверка подмножества</h4>
        <p>Проверить, является ли один массив подмножеством другого.</p>
<pre>
  <code class="lang-js">
    const isSubset = (arr1, arr2) => {
      return arr2.every(el => arr1.includes(el));
    };
    console.log(isSubset([1, 2, 3, 4], [2, 3])); // true
    console.log(isSubset([1, 2, 3, 4], [5]));    // false
  </code>
</pre>
        <h4>2.4. Перемещение нулей в конец массива</h4>
        <p>Переместить все нули в конец массива, сохранив порядок остальных элементов.</p>
<pre>
  <code class="lang-js">
    const moveZeroes = arr => {
      return arr.filter(el => el !== 0).concat(arr.filter(el => el === 0));
    };
    console.log(moveZeroes([0, 1, 0, 3, 12])); // [1, 3, 12, 0, 0]
  </code>
</pre>
        <h4>2.5. Найти максимальное произведение пары чисел в массиве</h4>
        <p>Вычислить максимальное произведение двух чисел.</p>
<pre>
  <code class="lang-js">
    const maxProduct = arr => {
      let max1 = -Infinity, max2 = -Infinity, min1 = Infinity, min2 = Infinity;
      for (const num of arr) {
        if (num > max1) [max1, max2] = [num, max1];
        else if (num > max2) max2 = num;
  
        if (num < min1) [min1, min2] = [num, min1];
        else if (num < min2) min2 = num;
      }
      return Math.max(max1 * max2, min1 * min2);
    };
    console.log(maxProduct([1, -10, -20, 4, 3])); // 200
  </code>
</pre>
        <h4>2.6. Сумма минимальных чисел</h4>
        <p>Найти сумму двух минимальных чисел в массиве.</p>
<pre>
  <code class="lang-js">
    const sumOfMinTwo = arr => {
      const [min1, min2] = arr.sort((a, b) => a - b);
      return min1 + min2;
    };
    console.log(sumOfMinTwo([19, 5, 42, 2, 77])); // 7
  </code>
</pre>
        <h4>2.7. Удаление дубликатов с сохранением порядка</h4>
        <p>Удалить дубликаты из массива, сохранив порядок их первого появления.</p>
<pre>
  <code class="lang-js">
    const removeDuplicates = arr => {
      return arr.filter((item, index) => arr.indexOf(item) === index);
    };
    console.log(removeDuplicates([1, 2, 2, 3, 4, 4, 5])); // [1, 2, 3, 4, 5]
  </code>
</pre>
        <h4>2.8. Поиск пары с заданной суммой</h4>
        <p>Найти в массиве пару чисел, сумма которых равна заданному числу.</p>
<pre>
  <code class="lang-js">
    const findPair = (arr, target) => {
      const seen = new Set();
      for (const num of arr) {
        const complement = target - num;
        if (seen.has(complement)) return [complement, num];
        seen.add(num);
      }
      return null;
    };
    console.log(findPair([2, 7, 11, 15], 9)); // [2, 7]
  </code>
</pre>
        <h4>2.9. Ротация массива</h4>
        <p>Сместить массив на заданное количество шагов вправо.</p>
<pre>
  <code class="lang-js">
    const rotateArray = (arr, steps) => {
      const n = arr.length;
      steps = steps % n;
      return arr.slice(-steps).concat(arr.slice(0, n - steps));
    };
    console.log(rotateArray([1, 2, 3, 4, 5], 2)); // [4, 5, 1, 2, 3]
  </code>
</pre>
        <h4>2.10. Группировка элементов массива по чётности</h4>
        <p>Разделить массив на два подмассива: чётные и нечётные числа.</p>
<pre>
  <code class="lang-js">
    const groupByParity = arr => {
      const even = arr.filter(num => num % 2 === 0);
      const odd = arr.filter(num => num % 2 !== 0);
      return { even, odd };
    };
    console.log(groupByParity([1, 2, 3, 4, 5])); // { even: [2, 4], odd: [1, 3, 5] }
  </code>
</pre>
        <h4>2.11. Поиск наиболее часто встречающегося элемента</h4>
        <p>Найти элемент, который встречается чаще всего.</p>
<pre>
  <code class="lang-js">
    const mostFrequent = arr => {
      const freq = {};
      let maxCount = 0, maxItem;
      arr.forEach(item => {
        freq[item] = (freq[item] || 0) + 1;
        if (freq[item] > maxCount) {
          maxCount = freq[item];
          maxItem = item;
        }
      });
      return maxItem;
    };
    console.log(mostFrequent([1, 3, 3, 2, 1, 3, 4])); // 3
  </code>
</pre>
        <h4>2.12. Поиск отсутствующего числа</h4>
        <p>В массиве чисел от 1 до n найти отсутствующее число.</p>
<pre>
  <code class="lang-js">
    const findMissingNumber = arr => {
      const n = arr.length + 1;
      const totalSum = (n * (n + 1)) / 2;
      const actualSum = arr.reduce((sum, num) => sum + num, 0);
      return totalSum - actualSum;
    };
    console.log(findMissingNumber([1, 2, 4, 5])); // 3
  </code>
</pre>
        <h4>2.13. Объединение интервалов</h4>
        <p>Объединить пересекающиеся интервалы.</p>
<pre>
  <code class="lang-js">
    const mergeIntervals = intervals => {
      intervals.sort((a, b) => a[0] - b[0]);
      const result = [intervals[0]];
      for (const [start, end] of intervals.slice(1)) {
        const last = result[result.length - 1];
        if (start <= last[1]) {
          last[1] = Math.max(last[1], end);
        } else {
            result.push([start, end]);
        }
      }
      return result;
    };
    console.log(mergeIntervals([[1, 3], [2, 6], [8, 10], [15, 18]])); // [[1, 6], [8, 10], [15, 18]]
  </code>
</pre>
        <h4>2.14. Уникальные элементы в массиве</h4>
        <p>Напишите функцию, которая возвращает массив, содержащий только уникальные элементы.</p>
<pre>
  <code class="lang-js">
    const getUniqueElements = (arr) => {
      return [...new Set(arr)];
    };
  
    console.log(getUniqueElements([1, 2, 3, 2, 4, 1])); // [1, 2, 3, 4]
  </code>
</pre>
        <h4>2.15. Переворот массива</h4>
        <p>Реализуйте функцию, которая принимает массив и возвращает его в обратном порядке без использования встроенного метода reverse.</p>
<pre>
  <code class="lang-js">
    const reverseArray = (arr) => {
      const reversed = [];
      for (let i = arr.length - 1; i >= 0; i--) {
          reversed.push(arr[i]);
      }
      return reversed;
    };
  
    console.log(reverseArray([1, 2, 3, 4])); // [4, 3, 2, 1]
  </code>
</pre>
        <h3>3. Задачи на числа</h3>
        <h4>3.1. Сумма цифр числа</h4>
        <p>Найти сумму всех цифр числа.</p>
<pre>
  <code class="lang-js">
    const sumDigits = num => {
      return num.toString().split('').reduce((sum, digit) => sum + Number(digit), 0);
    };
    console.log(sumDigits(1234)); // 10
  </code>
</pre>
        <h4>3.2. Проверка числа на палиндром</h4>
        <p>Проверить, является ли число палиндромом.</p>
<pre>
  <code class="lang-js">
    const isPalindrome = num => {
      const str = num.toString();
      return str === str.split('').reverse().join('');
    };
    console.log(isPalindrome(121)); // true
    console.log(isPalindrome(123)); // false
  </code>
</pre>
        <h4>3.3. НОД двух чисел</h4>
        <p>Найти наибольший общий делитель (НОД) двух чисел.</p>
<pre>
  <code class="lang-js">
    const gcd = (a, b) => {
      while (b !== 0) {
        [a, b] = [b, a % b];
      }
      return a;
    };
    console.log(gcd(56, 98)); // 14
  </code>
</pre>
        <h4>3.4. Проверка на число Армстронга</h4>
        <p>Число Армстронга — это число, сумма цифр которого в степени длины числа равна самому числу.</p>
<pre>
  <code class="lang-js">
    const isArmstrong = num => {
      const str = num.toString();
      const length = str.length;
      const sum = str.split('').reduce((acc, digit) => acc + Math.pow(Number(digit), length), 0);
      return sum === num;
    };
    console.log(isArmstrong(153)); // true
    console.log(isArmstrong(123)); // false
  </code>
</pre>
        <h3>4. Задачи на комбинирование типов данных</h3>
        <h4>4.1. Группировка элементов по частоте</h4>
        <p>Группировать элементы массива по количеству их появления.</p>
<pre>
  <code class="lang-js">
    const groupByFrequency = arr => {
      const freqMap = {};
      arr.forEach(el => freqMap[el] = (freqMap[el] || 0) + 1);
      return freqMap;
    };
    console.log(groupByFrequency([1, 2, 2, 3, 3, 3])); // {1: 1, 2: 2, 3: 3}
  </code>
</pre>
        <h4>4.2. Проверка баланса скобок</h4>
        <p>Проверить, правильно ли расставлены скобки.</p>
<pre>
  <code class="lang-js">
    const isBalanced = str => {
      const stack = [];
      const map = { ')': '(', ']': '[', '}': '{' };
      for (const char of str) {
        if (['(', '[', '{'].includes(char)) {
          stack.push(char);
        } else if ([')', ']', '}'].includes(char)) {
            if (stack.pop() !== map[char]) return false;
        }
      }
      return stack.length === 0;
    };
    console.log(isBalanced("(a[b]c{d}e)")); // true
    console.log(isBalanced("(a[b)c{d}e)")); // false
  </code>
</pre>
        <h4>4.3. Преобразование массива объектов в объект</h4>
        <p>Создать объект, где ключами являются значения одного из свойств массива объектов, а значениями — соответствующие объекты.</p>
<pre>
  <code class="lang-js">
    const arrayToObject = (arr, key) => {
      return arr.reduce((acc, item) => {
        acc[item[key]] = item;
        return acc;
      }, {});
    };
    const data = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' },
      { id: 3, name: 'Charlie' }
    ];
    console.log(arrayToObject(data, 'id'));
    // {
    //    1: { id: 1, name: 'Alice' },
    //    2: { id: 2, name: 'Bob' },
    //    3: { id: 3, name: 'Charlie' }
    // }
  </code>
</pre>
        <h4>4.4. Конкатенация и фильтрация</h4>
        <p>Объединить несколько массивов, удалить дубликаты и оставить только числа.</p>
<pre>
  <code class="lang-js">
    const mergeAndFilter = (...arrays) => {
      return [...new Set(arrays.flat().filter(item => typeof item === 'number'))];
    };
    console.log(mergeAndFilter([1, 'a', 2], [3, 4, 'b'], [2, 5, 6]));
    // [1, 2, 3, 4, 5, 6]
  </code>
</pre>
        <h4>4.5. Подсчёт частоты слов в строке</h4>
        <p>Подсчитать, сколько раз каждое слово встречается в строке.</p>
<pre>
  <code class="lang-js">
    const wordFrequency = str => {
      return str.toLowerCase().split(/\W+/).reduce((acc, word) => {
        if (word) acc[word] = (acc[word] || 0) + 1;
        return acc;
      }, {});
    };
    console.log(wordFrequency("Hello world! Hello again."));
    // { hello: 2, world: 1, again: 1 }
  </code>
</pre>
        <h4>4.6. Фильтрация уникальных объектов</h4>
        <p>Оставить в массиве только уникальные объекты по заданному ключу.</p>
<pre>
  <code class="lang-js">
    const uniqueByKey = (arr, key) => {
      const seen = new Set();
      return arr.filter(item => {
        const value = item[key];
        if (seen.has(value)) return false;
        seen.add(value);
        return true;
      });
    };
    const data = [
      { id: 1, name: 'Alice' },
      { id: 2, name: 'Bob' },
      { id: 1, name: 'Alice' }
    ];
    console.log(uniqueByKey(data, 'id'));
    // [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }]
  </code>
</pre>
        <h4>4.7. Слияние объектов с пересекающимися ключами</h4>
        <p>Объединить два объекта, суммируя значения одинаковых ключей.</p>
<pre>
  <code class="lang-js">
    const mergeObjects = (obj1, obj2) => {
      const result = { ...obj1 };
      for (const [key, value] of Object.entries(obj2)) {
        result[key] = (result[key] || 0) + value;
      }
      return result;
    };
    console.log(mergeObjects({ a: 1, b: 2 }, { b: 3, c: 4 }));
    // { a: 1, b: 5, c: 4 }
  </code>
</pre>
        <h4>4.8. Группировка элементов по свойству</h4>
        <p>Сгруппировать массив объектов по значению указанного свойства.</p>
<pre>
  <code class="lang-js">
    const groupBy = (arr, key) => {
      return arr.reduce((acc, item) => {
        const group = item[key];
        acc[group] = acc[group] || [];
        acc[group].push(item);
        return acc;
      }, {});
    };
    const data = [
      { name: 'Alice', role: 'developer' },
      { name: 'Bob', role: 'designer' },
      { name: 'Charlie', role: 'developer' }
    ];
    console.log(groupBy(data, 'role'));
    // {
    //     developer: [
    //        { name: 'Alice', role: 'developer' },
    //        { name: 'Charlie', role: 'developer' }
    //     ],
    //     designer: [
    //        { name: 'Bob', role: 'designer' }
    //     ]
    // }
  </code>
</pre>
        <h4>4.9. Преобразование строки JSON</h4>
        <p>Преобразовать строку JSON в массив объектов и отсортировать по значению ключа.</p>
<pre>
  <code class="lang-js">
    const sortJsonArray = (jsonStr, key) => {
      const arr = JSON.parse(jsonStr);
      return arr.sort((a, b) => (a[key] > b[key] ? 1 : -1));
    };
    const jsonData = '[{"name":"Charlie","age":30},{"name":"Alice","age":25},{"name":"Bob","age":35}]';
    console.log(sortJsonArray(jsonData, 'name'));
    // [{ name: "Alice", age: 25 }, { name: "Bob", age: 35 }, { name: "Charlie", age: 30 }]
  </code>
</pre>
        <h4>4.10. Сравнение массивов объектов</h4>
        <p>Найти различия между двумя массивами объектов.</p>
<pre>
  <code class="lang-js">
    const diffObjects = (arr1, arr2, key) => {
      const set2 = new Set(arr2.map(item => item[key]));
      return arr1.filter(item => !set2.has(item[key]));
    };
    const arr1 = [{ id: 1 }, { id: 2 }, { id: 3 }];
    const arr2 = [{ id: 2 }, { id: 3 }];
    console.log(diffObjects(arr1, arr2, 'id'));
    // [{ id: 1 }]
  </code>
</pre>
        <h4>4.11. Упрощение структуры данных</h4>
        <p>Преобразовать массив вложенных объектов в плоский массив ключей.</p>
<pre>
  <code class="lang-js">
    const flattenKeys = obj => {
      const keys = [];
      const recurse = (current, prefix = '') => {
        for (const key in current) {
          const newKey = prefix ? `${prefix}.${key}` : key;
          if (typeof current[key] === 'object') {
            recurse(current[key], newKey);
          } else {
            keys.push(newKey);
          }
        }
      };
      recurse(obj);
      return keys;
    };
    console.log(flattenKeys({ a: { b: { c: 1 }, d: 2 }, e: 3 }));
    // ["a.b.c", "a.d", "e"]
  </code>
</pre>
        <h3>5. Массивы и объекты</h3>
        <h4>5.1. Объединение массивов с приоритетом</h4>
        <p>Объединить два массива объектов, сохранив уникальные элементы. Если объект с одинаковым ключом присутствует в обоих массивах, использовать элемент из первого массива.</p>
<pre>
  <code class="lang-js">
    const mergeWithPriority = (arr1, arr2, key) => {
      const map = new Map(arr2.map(item => [item[key], item]));
      arr1.forEach(item => map.set(item[key], item));
      return Array.from(map.values());
    };
    const arr1 = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
    const arr2 = [{ id: 2, name: 'Robert' }, { id: 3, name: 'Charlie' }];
    console.log(mergeWithPriority(arr1, arr2, 'id'));
    // [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }, { id: 3, name: 'Charlie' }]
  </code>
</pre>
        <h4>5.2. Сравнение массивов объектов по нескольким полям</h4>
        <p>Выявить различия между двумя массивами объектов, сравнивая их по нескольким ключам.</p>
<pre>
  <code class="lang-js">
    const diffByFields = (arr1, arr2, keys) => {
      const serialize = obj => keys.map(key => obj[key]).join('|');
      const set2 = new Set(arr2.map(serialize));
      return arr1.filter(item => !set2.has(serialize(item)));
    };
    const arr1 = [{ id: 1, name: 'Alice' }, { id: 2, name: 'Bob' }];
    const arr2 = [{ id: 2, name: 'Bob' }, { id: 3, name: 'Charlie' }];
    console.log(diffByFields(arr1, arr2, ['id', 'name']));
    // [{ id: 1, name: 'Alice' }]
  </code>
</pre>
        <h4>5.3. Глубокое объединение объектов</h4>
        <p>Объединить два объекта, учитывая вложенные структуры.</p>
<pre>
  <code class="lang-js">
    const deepMerge = (obj1, obj2) => {
      const result = { ...obj1 };
      for (const [key, value] of Object.entries(obj2)) {
        if (typeof value === 'object' && value !== null && typeof result[key] === 'object') {
          result[key] = deepMerge(result[key], value);
        } else {
          result[key] = value;
        }
      }
      return result;
    };
    const obj1 = { a: 1, b: { c: 2, d: 3 } };
    const obj2 = { b: { c: 10, e: 4 }, f: 5 };
    console.log(deepMerge(obj1, obj2));
    // { a: 1, b: { c: 10, d: 3, e: 4 }, f: 5 }
  </code>
</pre>
        <h4>5.4. Поиск циклических зависимостей</h4>
        <p>Выявить циклические зависимости в графе объектов.</p>
<pre>
  <code class="lang-js">
    const hasCycle = (graph) => {
      const visited = new Set();
      const stack = new Set();
  
      const dfs = (node) => {
        if (stack.has(node)) return true;
        if (visited.has(node)) return false;
  
        visited.add(node);
        stack.add(node);
  
        for (const neighbor of graph[node] || []) {
          if (dfs(neighbor)) return true;
        }
  
        stack.delete(node);
        return false;
      };
  
      return Object.keys(graph).some(node => dfs(node));
    };
    const graph = {
      A: ['B'],
      B: ['C'],
      C: ['A'] // Цикл: A → B → C → A
    };
    console.log(hasCycle(graph));
    // true
  </code>
</pre>
        <h4>5.5. Группировка по диапазонам значений</h4>
        <p>Сгруппировать массив чисел по заданным диапазонам.</p>
<pre>
  <code class="lang-js">
    const groupByRange = (arr, ranges) => {
      const groups = {};
      for (const num of arr) {
        const range = ranges.find(([min, max]) => num >= min && num <= max);
        const key = range ? `${range[0]}-${range[1]}` : 'others';
        groups[key] = groups[key] || [];
        groups[key].push(num);
      }
      return groups;
    };
    const numbers = [1, 5, 10, 15, 20, 25, 30];
    const ranges = [[0, 10], [11, 20], [21, 30]];
    console.log(groupByRange(numbers, ranges));
    // { '0-10': [1, 5, 10], '11-20': [15, 20], '21-30': [25, 30] }
  </code>
</pre>
        <h4>5.6. Обратный маппинг</h4>
        <p>Создать обратный маппинг из объекта: значения становятся ключами, а ключи — значениями.</p>
<pre>
  <code class="lang-js">
    const reverseMapping = (obj) => {
      return Object.entries(obj).reduce((acc, [key, value]) => {
        acc[value] = key;
        return acc;
      }, {});
    };
    const mapping = { a: 1, b: 2, c: 3 };
    console.log(reverseMapping(mapping));
    // { 1: 'a', 2: 'b', 3: 'c' }
  </code>
</pre>
        <h3>6. Обработка данных, API и реализация структур данных:</h3>
        <h4>6.1. Получение и обработка данных из API</h4>
        <p>Выполнить запрос к API, обработать данные и вывести список с определённым форматом.</p>
        <p><strong>Задача:</strong> Получить данные пользователей с <a href="https://jsonplaceholder.typicode.com/users">https://jsonplaceholder.typicode.com/users</a> и вывести их имена и адреса в виде строки: Имя: <code>[Name], Адрес: [Street], [City]</code>.</p>
<pre>
  <code class="lang-js">
    const fetchUsers = async () => {
      try {
        const response = await fetch('https://jsonplaceholder.typicode.com/users');
        const users = await response.json();
        users.forEach(user => {
          console.log(`Имя: ${user.name}, Адрес: ${user.address.street}, ${user.address.city}`);
        });
      } catch (error) {
          console.error('Ошибка при загрузке данных:', error);
      }
    };
    fetchUsers();
  </code>
</pre>
        <h4>6.2. Создание кеширующего API</h4>
        <p>Создать функцию, которая кэширует результаты вызова API, чтобы избежать повторных запросов с одинаковыми параметрами.</p>
        <p><strong>Задача</strong>: Реализовать кэш для функции <code>fetch</code>.</p>
<pre>
  <code class="lang-js">
    const createCachedFetch = () => {
      const cache = new Map();
      return async (url) => {
        if (cache.has(url)) {
          console.log('Данные из кэша:', url);
          return cache.get(url);
        }
        const response = await fetch(url);
        const data = await response.json();
        cache.set(url, data);
        return data;
      };
    };
  
    const cachedFetch = createCachedFetch();
    cachedFetch('https://jsonplaceholder.typicode.com/posts/1').then(console.log);
    cachedFetch('https://jsonplaceholder.typicode.com/posts/1').then(console.log);
  </code>
</pre>
        <h4>6.3. Реализация структуры данных — очередь</h4>
        <p>Реализовать очередь с методами <code>enqueue</code>, <code>dequeue</code> и <code>peek</code>.</p>
<pre>
  <code class="lang-js">
    class Queue {
      constructor() {
        this.items = [];
      }
  
      enqueue(item) {
        this.items.push(item);
      }
  
      dequeue() {
        return this.items.shift();
      }
  
      peek() {
        return this.items[0];
      }
  
      isEmpty() {
        return this.items.length === 0;
      }
    }
  
    const queue = new Queue();
    queue.enqueue(1);
    queue.enqueue(2);
    console.log(queue.peek()); // 1
    console.log(queue.dequeue()); // 1
    console.log(queue.isEmpty()); // false
  </code>
</pre>
        <h4>6.4. Реализация связного списка</h4>
        <p>Создать связный список с базовыми методами (<code>add</code>, <code>remove</code>, <code>find</code>).</p>
<pre>
  <code class="lang-js">
    class Node {
      constructor(value) {
        this.value = value;
        this.next = null;
      }
    }
  
    class LinkedList {
      constructor() {
        this.head = null;
      }
  
      add(value) {
        const newNode = new Node(value);
        if (!this.head) {
          this.head = newNode;
        } else {
            let current = this.head;
              while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
      }
  
      remove(value) {
        if (!this.head) return;
        if (this.head.value === value) {
          this.head = this.head.next;
          return;
        }
        let current = this.head;
        while (current.next && current.next.value !== value) {
          current = current.next;
        }
        if (current.next) {
          current.next = current.next.next;
        }
      }
  
      find(value) {
        let current = this.head;
        while (current) {
          if (current.value === value) return current;
          current = current.next;
        }
        return null;
      }
    }
  
    const list = new LinkedList();
    list.add(1);
    list.add(2);
    list.add(3);
    console.log(list.find(2)); // Node { value: 2, next: Node { value: 3, next: null } }
    list.remove(2);
    console.log(list.find(2)); // null
  </code>
</pre>
        <h4>6.5. Обработка вложенных данных</h4>
        <p>Развернуть массив объектов, содержащий вложенные массивы.</p>
        <p><strong>Задача:</strong> Написать функцию, которая развернёт массив с вложенными массивами в один плоский массив.</p>
<pre>
  <code class="lang-js">
    const flattenArray = (arr) => {
      return arr.reduce((flat, item) => {
        return flat.concat(Array.isArray(item) ? flattenArray(item) : item);
      }, []);
    };
  
    const nestedArray = [1, [2, [3, [4]], 5]];
    console.log(flattenArray(nestedArray));
    // [1, 2, 3, 4, 5]
  </code>
</pre>
        <h4>6.6. Группировка данных</h4>
        <p>Группировать данные по значению ключа.</p>
        <p><strong>Задача:</strong> Группировать пользователей по их возрасту.</p>
<pre>
  <code class="lang-js">
    const groupBy = (arr, key) => {
      return arr.reduce((groups, item) => {
        const group = item[key];
        groups[group] = groups[group] || [];
        groups[group].push(item);
        return groups;
      }, {});
    };
  
    const users = [
      { name: 'Alice', age: 25 },
      { name: 'Bob', age: 30 },
      { name: 'Charlie', age: 25 },
      { name: 'David', age: 30 }
    ];
    console.log(groupBy(users, 'age'));
    // { '25': [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 25 }],
    //   '30': [{ name: 'Bob', age: 30 }, { name: 'David', age: 30 }] }
  </code>
</pre>
        <h3>7. Алгоритмы и паттерны проектирования</h3>
        <h4>7.1. Алгоритм сортировки — Быстрая сортировка (Quick Sort)</h4>
        <p>Реализовать алгоритм быстрой сортировки для массива чисел.</p>
<pre>
  <code class="lang-js">
    const quickSort = (arr) => {
      if (arr.length <= 1) return arr;
      const pivot = arr[arr.length - 1];
      const left = arr.filter((el) => el < pivot);
      const right = arr.filter((el) => el > pivot);
      return [...quickSort(left), pivot, ...quickSort(right)];
    };
  
    const unsortedArray = [5, 3, 8, 4, 2, 7, 1, 10];
    console.log(quickSort(unsortedArray)); 
    // [1, 2, 3, 4, 5, 7, 8, 10]
  </code>
</pre>
        <h4>7.2. Паттерн проектирования — Singleton</h4>
        <p>Реализовать Singleton, который гарантирует создание только одного экземпляра объекта.</p>
<pre>
  <code class="lang-js">
    class Singleton {
      constructor() {
        if (Singleton.instance) {
          return Singleton.instance;
        }
        Singleton.instance = this;
        this.timestamp = Date.now();
      }
  
      getInstance() {
        return this;
      }
    }
  
    const instance1 = new Singleton();
    const instance2 = new Singleton();
  
    console.log(instance1 === instance2); // true
    console.log(instance1.timestamp); // одинаковый timestamp
  </code>
</pre>
        <h4>7.3. Алгоритм — Проверка сбалансированных скобок</h4>
        <p>Написать функцию, которая проверяет, сбалансированы ли скобки в строке.</p>
<pre>
  <code class="lang-js">
    const isBalanced = (str) => {
      const stack = [];
      const pairs = {
        ')': '(',
        ']': '[',
        '}': '{',
      };
  
      for (const char of str) {
        if (['(', '[', '{'].includes(char)) {
          stack.push(char);
        } else if ([')', ']', '}'].includes(char)) {
          if (stack.pop() !== pairs[char]) {
            return false;
          }
        }
      }
  
      return stack.length === 0;
    };
  
    console.log(isBalanced("{[()]}")); // true
    console.log(isBalanced("{[(])}")); // false
    console.log(isBalanced("{{[[(())]]}}")); // true
  </code>
</pre>
        <h4>7.4. Функциональное программирование — Каррирование (Currying)</h4>
        <p>Реализовать функцию для каррирования.</p>
<pre>
  <code  class="lang-js">
    const curry = (fn) => {
      return function curried(...args) {
          if (args.length >= fn.length) {
              return fn(...args);
          } else {
              return (...nextArgs) => curried(...args, ...nextArgs);
          }
      };
    };
  
    const add = (a, b, c) => a + b + c;
    const curriedAdd = curry(add);
  
    console.log(curriedAdd(1)(2)(3)); // 6
    console.log(curriedAdd(1, 2)(3)); // 6
    console.log(curriedAdd(1, 2, 3)); // 6
  </code>
</pre>
        <h4>7.5. Реализация паттерна Observer</h4>
        <p>Создать простую реализацию паттерна Observer.</p>
<pre>
  <code class="lang-js">
    class Observable {
      constructor() {
        this.observers = [];
      }
  
      subscribe(observer) {
        this.observers.push(observer);
      }
  
      unsubscribe(observer) {
        this.observers = this.observers.filter((obs) => obs !== observer);
      }
  
      notify(data) {
        this.observers.forEach((observer) => observer(data));
      }
    }
  
    const observable = new Observable();
  
    const observer1 = (data) => console.log(`Observer 1: ${data}`);
    const observer2 = (data) => console.log(`Observer 2: ${data}`);
  
    observable.subscribe(observer1);
    observable.subscribe(observer2);
  
    observable.notify('Hello Observers!'); 
    // Observer 1: Hello Observers!
    // Observer 2: Hello Observers!
  
    observable.unsubscribe(observer1);
  
    observable.notify('Second message'); 
    // Observer 2: Second message
  </code>
</pre>
        <h4>7.6. Генерация всех возможных перестановок строки</h4>
        <p>Реализовать функцию, которая генерирует все перестановки заданной строки.</p>
<pre>
  <code class="lang-js">
    const permutations = (str) => {
      if (str.length <= 1) return [str];
      const result = [];
      for (let i = 0; i < str.length; i++) {
        const char = str[i];
        const remaining = str.slice(0, i) + str.slice(i + 1);
        for (const perm of permutations(remaining)) {
          result.push(char + perm);
        }
      }
      return result;
    };
  
    console.log(permutations("abc")); 
    // ['abc', 'acb', 'bac', 'bca', 'cab', 'cba']
  </code>
</pre>
        <h4>7.7. Алгоритм — Сжатие строки</h4>
        <p>Написать функцию, которая сжимает строку, заменяя повторяющиеся символы на количество их повторений.</p>
<pre>
  <code class="lang-js">
    const compressString = (str) => {
      let compressed = '';
      let count = 1;
  
      for (let i = 1; i <= str.length; i++) {
        if (str[i] === str[i - 1]) {
          count++;
        } else {
          compressed += str[i - 1] + (count > 1 ? count : '');
          count = 1;
        }
      }
  
      return compressed;
    };
  
    console.log(compressString("aaabccddd")); // a3bc2d3
    console.log(compressString("abcd")); // abcd
  </code>
</pre>

      </article>
    </main>

    <!--блок в нижней части страницы-->
    <footer> 
      <p>©Copyright 2024 by nobody. All rights reversed.</p>
    </footer>

  </body>
</html>